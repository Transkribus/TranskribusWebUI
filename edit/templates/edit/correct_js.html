{% load staticfiles %}

{# We use ImageMapster for the map and to resize the image. #}
<script src="{% static "js/jquery.imagemapster.min.js" %}"></script>
<script>
// TODO JSON vs. map vs. whatever!??????


	var lineArray= [['',0]{# This is needed because the top of the page is a "line" in the "typewriter" #}
		{% for line in lines %}
			,['{{ line|get_item:"id"}}', {{line|get_item:"crop"| y_for_typewriterline}}]
		{% endfor %}
	];  
	var line_index = 0;
	var line_top_spacing = 50;{# TODO Set this to an appropriate value automagically? Or just a default? And configurable? The line polygons are too small anyway. #}
	var zoom =  0;
	var initial_width;
	var scroll_factor;
	var content = {{ content|safe}};
	var savedFocusId;{# TODO Consider a getter? #}
	var enterLineId;
	var changed = false;
	var isDragged = false;
	
	function hasChanged() {
		if (!changed)
			setMessage("Trans blah... you have unsaved changes.");
		changed = true;
	}
	function setMessage(message) {
		$("#message").html(message);
	}
	function selectLine(lineId) {
		$("[line-key$=" + lineId + "]").mapster('set', true);
	}
	function deselectLine(lineId) {
		$("[line-key$=" + lineId + "]").mapster('set', false);
	}
	function saveFocusId(lineId) {
		savedFocusId = lineId;
	}	
	function appendLine(lineId) {
		$(".line-list").append('<li><input class="form-control added-line" type="text" id="' + lineId +'" value="' + content[lineId] + '" onblur="saveFocusId(this.id);"  /></li>');
	}
	function prependLine(lineId) {
		$(".line-list").prepend('<li><input class="form-control added-line" type="text" id="' + lineId +'" value="' + content[lineId] + '" onblur="saveFocusId(this.id);"  /></li>');
	}
	function oneLineUp() {{# Aka. typewriter scroll #}
			newLineId = getNextLineId($('.added-line').last().attr("id"));
			appendLine(newLineId);	
			selectLine(newLineId);
			
			firstLine = $('.added-line').first();
			deselectLine(firstLine.attr("id"));
			firstLine.remove();

			saveFocusId(getNextLineId(enterLineId));{# The line in the same _location_  in which enter was pressed should be focused. #}
			$("[id$=" + savedFocusId + "]").focus();{# We set focus to the line following the one the user was working on when "typewriter scrolling" so that the line in the same location is focused. #}
			vScrollDown(); {# TODO Request feedback. Do we want the scrolling to be according to the "page position" or assume that the user wants the highlighted line to be on top? The user can get it like this but also (confusingly?) other offsets... #}
	}
	function oneLineDown() {
			newLineId = getPreviousLineId($('.added-line').first().attr("id"));
			prependLine(newLineId);	
			selectLine(newLineId);
			
			lastLine = $('.added-line').last();
			deselectLine(lastLine.attr("id"));
			lastLine.remove();

			{# TODO Figure out if this is still wrong? #}
			saveFocusId(getNextLineId(enterLineId));{# The line in the same _location_  in which enter was pressed should be focused. #}
			
			$("[id$=" + savedFocusId + "]").focus();{# We set focus to the line following the one the user was working on when "typewriter scrolling" so that the line in the same location is focused. #}
			vScrollUp(); {# TODO Request feedback. Do we want the scrolling to be according to the "page position" or assume that the user wants the highlighted line to be on top? The user can get it like this but also (confusingly?) other offsets... #}
	}
	function removeLastLine() {
		if ($('.added-line').size() > 1) { {# TODO Remove the minus button when only one line is shown? For aesthetic reasons... #}
			line = $('.added-line').last();
			deselectLine(line.attr("id"));
			line.remove();
		}
	}
	function getLineContent(lineId) {
		return content[lineId];
	}
	function setLineContent(lineId, lineContent) { {# We update the content array with the edited content. #}
		if (content[lineId] != lineContent) {
			hasChanged();
			content[lineId] = lineContent;
		}
	}
	function getNextLineId(currentLineId) {
		var i = 0
		while (i < lineArray.length) {
			if (lineArray[i][0] == currentLineId)
				break;
			i++;
		}{# TODO No match....!? #}
		return lineArray[i+1][0];
	}
	function getPreviousLineId(currentLineId) {
		var i = 0
		while (i < lineArray.length) {
			if (lineArray[i][0] == currentLineId)
				break;
			i++;
		}{# TODO No match....!? #}
		return lineArray[i-1][0];
	}
	function vScrollDown() {
		line_index++;
		if (lineArray. length == line_index)
			line_index--;
		$( ".transcript-map-div" ).css("top", Math.round(scroll_factor*(-lineArray[line_index][1] + line_top_spacing)) + 'px');
	}
	function vScrollUp() {
		line_index--;
		if (0 >= line_index) {
			line_index = 0;
			$( ".transcript-map-div" ).css("top", '0px');{# We don't want the top spacing in this case. #}
		} else 
			$( ".transcript-map-div" ).css("top", Math.round(scroll_factor*(-lineArray[line_index][1] + line_top_spacing)) + 'px');
	}
	{# Call this after dragging to so to get an appropriate line_index for stepwise scrolling again. #}
	function adaptLineIndex() {
		dragToComparable =  line_top_spacing -parseInt($( ".transcript-map-div" ).css("top"), 10)/scroll_factor;
		length = lineArray.length;
		if (dragToComparable > lineArray[length - 1][1])
			line_index = length - 1;
		else {
			for (i = 0; i < length; i++) {
				if (dragToComparable < lineArray[i][1]) {
					line_index = Math.max(0, i - 1);
					i = length;{# Exit the loop. #}
				}
			}
		}
	}
	function updateZoom() {
		var zoom_factor = zoom / 100;
		$('#transcriptImage').mapster('resize', Math.round(initial_width * (1 + zoom_factor))); 
		scroll_factor = $('#transcriptImage').width() / $('#transcriptImage').get(0).naturalWidth;
		if (0 == line_index)
			$( ".transcript-map-div" ).css("top", '0px');{# TODO This is needed elsewhere as well, separate the scrolling! #}
		else
			$( ".transcript-map-div" ).css("top", Math.round(scroll_factor*(-lineArray[line_index][1] + line_top_spacing)) + 'px');
	}
	
	$("a[data-target=#saveChanges]").click(function(event) {
    	event.preventDefault();
    	$.post('correct', {content: JSON.stringify(content), csrfmiddlewaretoken: '{{ csrf_token }}'}, function( data ) {
    		setMessage(data); 
		});
    	// TODO Handle failures here or are we happy with the current solution?
	});
	$(function() {
		$('#correctModal').draggable({
	       handle: $('.modal-header')
		});
		$('.transcript-map-div').draggable({
			start: function() {
				isDragged = true;
				$('area').mapster('set', false); {# We assume that the user does not want to select a region. #}
			},
			stop: function() {
				adaptLineIndex();
				setTimeout(function() { {# A hack to avoid triggering clicks on the map if clicking a region when dragging. #}
					isDragged = false;
					$('area').mapster('set', false);
				}, 250);
			}
		});
		$('#correctModal').on('hidden.bs.modal', function () {
			$('area').mapster('set', false);
			$(".line-list").html('');
		});
		$('#correctModal').on('shown.bs.modal', function (e) {
			saveFocusId(document.querySelectorAll('.added-line')[0].id);
			$("[id$=" + savedFocusId + "]").focus();
		});
		$( "#transcriptMap  area" ).on('click', function(e) {	
			if (isDragged) {# We ignore clicks if the user has been dragging the image, we assume that that's what the user wants. #}
				return;
			lineId = $(this).attr("line-key");
			saveFocusId(lineId);
			$("#correctModal").modal();
			appendLine(lineId);
		});
		$( ".scroll-up" ).on('click', function(e) {
			vScrollUp();
		});
		$( ".scroll-down" ).on('click', function(e) {
			vScrollDown();
		});
		{# TODO Fix focus in these two. The enter key does the trick below but not with these buttons. #}
		{# TODO Request feedback. Is up/down more logical like this? #}
		$( ".typewriter-up" ).on('click', function(e) {
			oneLineDown();
		});
		$( ".typewriter-down" ).on('click', function(e) {
			oneLineUp();
		});
		$( ".zoom-in" ).on('click', function(e) {
			zoom += 10;
			updateZoom();
		});
		$( ".zoom-out" ).on('click', function(e) {
			zoom -= 10;
			updateZoom();
		});
		$( ".add-line" ).on('click', function(e) {
			lineId = getNextLineId($('.line-list input').last().attr("id"))
			appendLine(lineId);
			selectLine(lineId);
			$("[id$=" + savedFocusId + "]").focus();
		});
		$( ".remove-line" ).on('click', function(e) {
			removeLastLine();
		});
        $('.transcript-map-div').on('mousewheel DOMMouseScroll', function(e) {
        	e.preventDefault();
        	if (e.originalEvent.detail > 0)
				zoom -= 10;        	
			else
				zoom += 10;
			updateZoom();
        });
	});
	$(document).ready(function() {
		$('#transcriptImage').mapster({
			mapKey: 'line-key',
	        render_highlight: {
		        fade: false,
	            fillColor: 'ffffff',
	            fillOpacity: 0.1
	        },
		    render_select: {
            	fillColor: 'ffffff',
            	fillOpacity: 0.1   
	        }
		});;
		$('#transcriptImage').one("load", function() {
			initial_width = $('#transcriptImage').width();
			scroll_factor = initial_width / $('#transcriptImage').get(0).naturalWidth;
		});
		$('#correctModal').keydown(function(e){
		    if (e.keyCode == 13) {
				enterLineId = e.target.id;{# This is only used when focus is lost because the user clicks "plus" to add a new line. Not really necessary when focus is changed due to input field changes. #}
		        oneLineUp();
		    }
		});
		$('#correctModal').focusout(function(e) { {# When a line being edited loses focus, we preserve the content and thus update the array. #}
			setLineContent(e.target.id, e.target.value);
		});
	});
</script>